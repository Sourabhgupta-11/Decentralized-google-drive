{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-e1ec5d4599fb7d9e206f8973645244d0568c8cab",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/fileShare.sol": "project/contracts/fileShare.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/fileShare.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.19;\r\n\r\ncontract DecentralizedDrive {\r\n\r\n    // ---------------- STRUCT ----------------\r\n    struct File {\r\n        uint256 id;\r\n        string name;\r\n        string ipfsHash;\r\n        address owner;\r\n        uint256 uploadedAt;\r\n        bool allowReshare;\r\n    }\r\n\r\n    // ---------------- STATE VARIABLES ----------------\r\n    uint256 private fileCounter;  //total files in that contract\r\n\r\n    mapping(uint256 => File) private files;  //eg: file[1]={1,name,ipfs,..} means in id 1 this file is there\r\n\r\n    mapping(address => uint256[]) private userFiles; //eg: userFiles[0xabc...]=[1,3,6] this address has access to file id - 1,3,6\r\n\r\n    mapping(address => uint256[]) private sharedFiles;  //eg: sharedFiles[0xabc..]=[2,4] this address has been shared with file id 2,4 and now access to it\r\n\r\n    mapping(uint256 => mapping(address => bool)) private fileAccess;   //eg: fileAccess[1][0xabc..]=true means fileid 1 can be accessed by address 0xabc..\r\n\r\n    // ---------------- EVENTS ----------------(events are like notification)\r\n    event FileUploaded(\r\n        uint256 indexed fileId,\r\n        address indexed owner,\r\n        string ipfsHash\r\n    );\r\n\r\n    event FileShared(\r\n        uint256 indexed fileId,\r\n        address indexed from,\r\n        address indexed to\r\n    );\r\n\r\n    event FileDeleted(\r\n        uint256 indexed fileId,\r\n        address indexed owner\r\n    );\r\n\r\n    // ---------------- UPLOAD FILE ----------------\r\n    function uploadFile(\r\n        string calldata _name,\r\n        string calldata _ipfsHash,\r\n        bool _allowReshare\r\n    ) external {\r\n        require(bytes(_ipfsHash).length > 0, \"Invalid IPFS hash\");\r\n\r\n        fileCounter++;\r\n\r\n        files[fileCounter] = File({\r\n            id: fileCounter,\r\n            name: _name,\r\n            ipfsHash: _ipfsHash,\r\n            owner: msg.sender,\r\n            uploadedAt: block.timestamp,\r\n            allowReshare: _allowReshare\r\n        });\r\n\r\n        userFiles[msg.sender].push(fileCounter);\r\n        fileAccess[fileCounter][msg.sender] = true;\r\n\r\n        emit FileUploaded(fileCounter, msg.sender, _ipfsHash);  //emit that event FileUploaded\r\n    }\r\n\r\n    // ---------------- VIEW MY FILES ----------------\r\n    function getMyFiles() external view returns (File[] memory) {\r\n        uint256[] memory ids = userFiles[msg.sender];\r\n        File[] memory result = new File[](ids.length);\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            result[i] = files[ids[i]];\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // ---------------- VIEW SHARED FILES ----------------\r\n    function getSharedFiles() external view returns (File[] memory) {\r\n        uint256[] memory ids = sharedFiles[msg.sender];\r\n        File[] memory result = new File[](ids.length);\r\n\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            result[i] = files[ids[i]];\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    // ---------------- SHARE FILE ----------------\r\n    function shareFile(uint256 _fileId, address _to) external {\r\n        require(fileAccess[_fileId][msg.sender], \"No access to file\");\r\n        require(_to != address(0), \"Invalid address\");\r\n\r\n        // If sender is not owner, resharing must be allowed\r\n        if (msg.sender != files[_fileId].owner) {\r\n            require(files[_fileId].allowReshare, \"Resharing not allowed\");\r\n        }\r\n\r\n        // Grant access - below code run only when owner of file do allowReshare is true\r\n        fileAccess[_fileId][_to] = true;\r\n        sharedFiles[_to].push(_fileId);\r\n\r\n        emit FileShared(_fileId, msg.sender, _to);\r\n    }\r\n\r\n    // ---------------- GET FILE (OWN OR SHARED) ----------------\r\n    function getFile(uint256 _fileId) external view returns (File memory) {\r\n        require(fileAccess[_fileId][msg.sender], \"Access denied\");\r\n        return files[_fileId];\r\n    }\r\n\r\n    // ---------------- CHECK ACCESS ----------------\r\n    function hasAccess(uint256 _fileId, address _user)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return fileAccess[_fileId][_user];\r\n    }\r\n\r\n    // ---------------- DELETE FILE ----------------\r\n    function deleteFile(uint256 _fileId) external {\r\n        require(files[_fileId].owner == msg.sender, \"Not file owner\");\r\n\r\n        // Remove owner access\r\n        fileAccess[_fileId][msg.sender] = false;\r\n\r\n        // Remove from owner's file list\r\n        uint256[] storage ids = userFiles[msg.sender];\r\n        for (uint256 i = 0; i < ids.length; i++) {\r\n            if (ids[i] == _fileId) {\r\n                ids[i] = ids[ids.length - 1];\r\n                ids.pop();\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Delete file metadata\r\n        delete files[_fileId];\r\n\r\n        emit FileDeleted(_fileId, msg.sender);\r\n    }\r\n}\r\n"
      }
    }
  }
}